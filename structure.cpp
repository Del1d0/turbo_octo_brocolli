class Controller // общий контроллер
{
public:
	virtual void getControls();
	virtual void setCoorinates(Entity& hostEntity); // ставит координаты своему Entity на основании решения Controller
};

class PlayerController : public Controller
{
public:
	void getControls() override; // вызовет getPlayerInput -> вычислит новое положение -> запишет новую координату в Host
	void setCoorinates(Player& hPlayer) override; // возможно в private убрать и вызывать только из getControls()
private:
	Action getPlayerInput(); // собирает общий ввод игрока - переводим кнопки в Action
	//Action - enum в котором содержатся действия типа стрельба, движение туда-то, смена оружия
};

// логика такая - EntityController двигает алгоритмом фоновые объекты, снаряды всякие
// и прочее, что просто по прямой летит (без отслеживания игрока)
class EntityController : public Controller //контролирует все, что не игрок
{
public:
	void getControls() override;
	void setCoorinates(Entity& hostEntity) override;
	// логику отслеживания игрока запихать сюда?
private:
	Coords movingAlgorithm(Coords& prevLocation); // пред. координаты берутся из hostEntity и в него же записываются новые
	// способ движения должен выбираться на основе типа Entity
	// может быть сделать отдельный файл с функциями для движения типа Utils и вызывать нужную 
};

// class EnemyController : public EntityController // контролирует врагов, которые следят за игроком
// хочется, чтобы враги отслеживали игрока и стреляли примерно в его сторону наподобие BulletHell



class Entity //(все, что на поле - враги разных типов, снаряды, ракеты, игрок, фоновые изображения?)
{
public:
	virtual Coords move(); //двигается контроллером (человек, алгоритм)
				 //снаряды летят по прямой, ракеты могут наводиться (?), лазеры по прямой, враги всяко разно (задать синусом или сплайном)
	virtual void OnCollision; //взаимодействие с другими Entity при контакте?
			 //не понятно, как сделать взаимодействие (квадратный хитбокс вокруг центра (Coords) Entity или что-то типа того)?
	//
protected:
	Controller mController;
	Coords mPos; //позиция
	Velocity mVel; //скорость (возможно разная для разных осей)
	
};

class ShootingEntity : public Entity // управляемая стреляющая штука (враги, игрок)
{
public:
	virtual void shoot(); //стреляет на основе решения контроллера (человек, алгоритм)
protected:
	int bulletCoolDown; // скорострельность пушки(не понятно как отсчитывать время между выстрелами)
						// добавить разные виды пушек (обычная, быстрая, взрывная и т.д.)
};

class EnemyEntity : public ShootingEntity // враги, стреляют в примерном направлении игрока (надо передать позицию игрока)
{ // буду наследоваться от EnemyEntity для создания разных врагов (ракетные дроны, стреляющие дроны, босс ракетовоз с лазерами и прочим)
public:
	void shoot() override(); // 
};

class Player : public ShootingEntity // (двигается, стреляет пушками, стреляет ракетами, лазерами и т.д.)
{
// помимо ХП сделать какой-нибудь щит, который теряется от ударов, его можно подзаряжать
public:
	void shoot() override;
private:
	//завести enum с типом вооружения, чтобы знать, какое сейчас активно
	int nRockets; // боезапас ракет
	int nLaserShots; // боезапас лазеров
	
	int hpVal;
	int hpCapacity;
	int shieldCapacity;
	int shieldVal;
};


class Game //(содержит игрока, и вектор сущностей)
{
public:
	void initGame(); // расставляем игрока, начальные облака и прочее
	void update(); // тут обновляем положения объектов, все стреляют, если время подошло
	{
		// обновить координаты игрока на основании ввода (или выстрелить)
		
		// обновить координаты врагов на основании их контроллеров
			// можно параметризовать кривую, по которой они двигаются, чтобы они шли друг за другом паравозиком по зигзагу
			// шахматный порядок или еще что, в зависимости от типа врага
		
		// обновить положения снарядов, ракет и прочего
		
		// передвинуть облака и прочие фоновые объекты вниз
			// столкновения с ними ничего не делают
			// вообще проверяется столкновение только игрока со снарядами, либо снарадов с врагами (враги не наносят урона своим)
		
		// передвинуть бонусы
		
		// прострелять всем кому можно (вообще у каждого типа врага разное оружие и скорострельность, соответсвенно,
		// нужно как-то отслеживать, что у врага идет КД (перезарядка) (заводить отдельный таймер для каждого типа оружия?)
	}
	void checkCollisions(); // проверяем столкновения, отнимаем ХП, подбираем бонусы
							// тут же проверку на выход за границу
	{
		// игрок вышел за гарницы поля? -> вернуть его назад на самую границу иначе ничего не делаем
		
		// враги вышли за границы поля + длина врага? -> удалить его (вызвать деструктор? или просто удалить из массива?)
		
		// проверяем попадание снаряда и пр. в область хитбокса игрока
			// если щит присутствует, то дамажим его, иначе дамажим игрока
		
		// проверяем бонусы, начисляем очки\хп\щиты\бусты\оружие (завести enum с бонусами)
	}
	bool checkGameOver(); // помер ли игрок
	{
		// if(p1.getHp() <= 0)
			//умираем
		
		// пока умираем только так, в приницпе, можно добавить режим, где мы защищаем союзника от волн, тогда добавится условие
		// на хп для союзника
	}
	void Render(); // какая-то отрисовка
	{
		// отрисовка фона
		// отрисовка игрока
		// отрисовка врагов
		// отрисовка снарядов
	}
	
private:
	Player mP1;
	
	std::vector<Entity*> mBackgroundObjects; // всякие объекты на карте, которые пролетают фоном (зациклить их просто при вылете за карту
											 // менять положение на рандомное по х, чтобы появлялись с разных сторон
											 // можно менять скорость на разную, чтобы возникал эффект параллакса (разная высота облаков)
	std::vector<Entity*> mProjectiles; // это снаряды, которые летают туда сюда и помирают при вылете за карту / попадании в игрока
	
	//будем подавать врагов волнами, и не будем делать новую волну, пока старая не погибнет
	std::vector<EnemyEntity*> mEnemies; // враги, добавляем \ убираем, когда нужно
	std::vector<BonusEntity*> mBonuses; // какие-нибудь бонусы, которые медленно плывут и их можно поднять (быстрая стрельба, лазер какой-нибудь)
	
	
	int xWindow;
	int yWindow; // размеры игрового поля (поле отрисовки), за которое нельзя вылетать (упираемся в невидимые стены)
				 // враги умирают при вылете за yWindow + длина хитбокса (чтобы не было видно, как они удаляются)
};

// в main уже есть цикл с некоторой частотой обновления, там будут вызываться update, checkCollisions, checkGameOver